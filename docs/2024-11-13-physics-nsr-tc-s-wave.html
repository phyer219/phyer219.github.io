<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
  <title>从冰上的水 - NSR 计算 s-wave BEC-BCS crossover 的临界温度</title>
  <meta name="generator" content="Pelican" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
           <link rel="stylesheet" type="text/css" href="/theme/css/style.css" />
  <!-- fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Long+Cang&family=Noto+Serif+SC&display=swap" rel="stylesheet" />
  <!--fonts end  -->
  <!-- highlight.js -->
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- highlight.js end -->

<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">




    <meta name="tags" content="NSR" />
    <meta name="tags" content="s-wave" />
    <meta name="tags" content="BEC-BCS crossover" />

</head>

<body class="star-background">
  <div class="container">
    <header>
      <section class="banner">
        <img id="banner-img" src="/images/banner.jpg" alt="banner-img" />
      </section>
    </header>
    <nav class="row">
      <a class="nav" href="/">首页</a>
      <a class="nav" href="/categories.html">分类</a>
      <a class="nav" href="/tags.html">标签</a>
        <a class="nav" href="/pages/about.html" aria-current="page">
        关于
      </a>
     </nav>

    <main>
  <h1 class="post-title">NSR 计算 s-wave BEC-BCS crossover 的临界温度</h1>

<section class="post-meta">
    <p>发表于: 2024-11-13 ||</p>
    <p>分类:<a class="post-link" href="/category/zhuan-ye-bi-ji.html">专业笔记</a> ||</p>
</section>

<section class="post-content">
  <h2>Sokhotski-Plemelj 积分</h2>
<p>根据 Sokhotski-Plemelj 定理有
\begin{align}
  \frac{1}{x + \mathrm{i}0^+}
  = \mathcal{P}\left(\frac{1}{x}\right) -\mathrm{i}\pi\delta(x)
\end{align}
因此有
\begin{align}
  \mathrm{Im} \int\mathrm{d}x\cdot \frac{f(x)}{a x^2 + bx + c + \mathrm{i}0^+}
   =  \frac{-\pi}{a|x_1-x_2|}\int \mathrm{d}x\cdot f(x)[\cdot \delta(x-x_1) + \delta(x - x_2)]
\end{align}
其中 \(x_1, x_2\) 是 \(a x^2 + bx + c\) 的两个根。在数值计算自能虚部时，对 \(q\) 的积分是
形如  的积分。</p>
<h2>计算积分 （<a href="./2024-11-13-physics-NSR-Tc-s-wave/nsr.py">源文件：nsr.py</a>）(大概运行了37分钟)</h2>
<p><pre>In [2]</pre></p><pre><code class="language-python"># Reference:
# 博士学位论文： BEC-BCS 过渡体系的热力学性质与旋量 BEC 中的非阿贝尔约瑟夫森效应的研究 齐燃
# 计算过程，全部以温度 T 做单位，进行无量纲化处理
import numpy as np
from scipy import integrate
from scipy.special import zeta
from scipy import optimize
from scipy.misc import derivative
import matplotlib.pyplot as plt
from mpmath import polylog


def bose(beta, energy):
    &quot;&quot;&quot; Bose 分布函数
    有些计算中, energy 也可能是负的.
    &quot;&quot;&quot;
    x = -beta * energy
    if energy &gt; 0:
        return np.exp(x) / (1 - np.exp(x))
    else:
        return 1 / (np.exp(-x) - 1)


def fermi(beta, energy):
    '''
    Fermi distribution function
    '''
    x = -beta * energy
    return np.exp(x) / (1 + np.exp(x))


def free_fermion_density(mu):
    &quot;&quot;&quot;
    Integrate[q^2/\[Pi]^2 1/(E^(q^2/2-\[Mu])+1),{q, 0, \[Infinity]}]
    &gt;&gt;  -(PolyLog[3/2,-E^\[Mu]]/(Sqrt[2] \[Pi]^(3/2)))
    &quot;&quot;&quot;
    return - polylog(s=3/2, z=-np.exp(mu)).real / (np.sqrt(2) * np.pi**(3/2))


class PrincipalValueInt():
    &quot;&quot;&quot;Calculate a 2nd order Cauchy integral:
    int  dx    f(x) / (a*x^2 + b^x + i0^+)
    latex:
    \int \mathrm{d}x \frac{f(x)}{a x^2 + b x + \mathrm{i}0^+}

    Attributes
    ----------
    get_image : float
                Calculate the imaginary part of the integral.
    get_real : float
        Calculate the real part of the integral.
    &quot;&quot;&quot;

    def __init__(self, numerator, coeff: list,
                 lower_lim, upper_lim, debug=False):
        &quot;&quot;&quot;
        numerator: function f(x)
        coeff: [a, b, c] is the coefficients in the denominator.
        lower_lim: lower limit of the integral
        upper_lim: upper limit of the integral
        &quot;&quot;&quot;
        self.debug = debug
        self.numerator = numerator
        if isinstance(numerator, (int, float)):
            self.numerator = lambda x: numerator
        else:
            self.numerator = numerator
        self.lower_lim = lower_lim
        self.upper_lim = upper_lim
        self.a = coeff[0]
        if self.a == 0:
            raise ValueError(&quot;a should not be 0!&quot;)  # TODO: deal the a=0 case.
        self.b = coeff[1]
        self.c = coeff[2]
        self.delta = self.b**2 - 4*self.a*self.c
        self.root_exist = (self.delta &gt; 0) and (self.a != 0)

        if self.root_exist:
            if self.a &gt; 0:
                self.root1 = (-self.b - np.sqrt(self.delta)) / (2*self.a)
                self.root2 = (-self.b + np.sqrt(self.delta)) / (2*self.a)
            else:
                self.root1 = (-self.b + np.sqrt(self.delta)) / (2*self.a)
                self.root2 = (-self.b - np.sqrt(self.delta)) / (2*self.a)
            # cherck if the roots in the integral interval
            self.root1_in = lower_lim &lt; self.root1 and self.root1 &lt; upper_lim
            self.root2_in = lower_lim &lt; self.root2 and self.root2 &lt; upper_lim

    def get_imag(self):
        &quot;&quot;&quot;Imaginary part of the integral.&quot;&quot;&quot;
        if self.root_exist:
            imag = (self.root1_in) * self.numerator(self.root1)
            imag += (self.root2_in) * self.numerator(self.root2)
            imag *= -np.pi / np.abs(self.root2 - self.root1)
        else:
            imag = 0
        imag *= 1/self.a
        return imag

    def get_real(self):
        &quot;&quot;&quot;
        Real part of the integral.

        Note(TODO):
        When upper_lim is very larg, e.g. self.upper_lim &gt; 1e4,
        if the function do not decay to 0, the result is wrong.
        The same warning in Mathematica:
        NIntegrate[1/(x-10^8)^2, {x, 1, 10^8+1}]
        &quot;&quot;&quot;
        if self.root_exist:
            if (not self.root1_in) and (not self.root2_in):
                if self.debug:
                    print('No root in!!!!!!!!!')
                res = integrate.quad((lambda x: self.numerator(x)
                                      / (self.a*x**2 + self.b*x + self.c)),
                                     self.lower_lim, self.upper_lim)[0]
                inte_metheod = 'no_root_in'
            elif self.root1_in and self.root2_in:
                if self.debug:
                    print('All root in~~~~~~~~~')
                mid = (self.root2 + self.root1)/2

                real1 = integrate.quad((lambda x: self.numerator(x)
                                        / (self.a * (x - self.root2))),
                                       self.lower_lim, mid,
                                       weight='cauchy', wvar=self.root1)[0]

                right_range = 2*self.root2 - self.root1
                if self.upper_lim &gt; right_range:
                    # 如果积分上限特别大, 就分段积, 要不然算法找不到 pole 的贡献.
                    if self.debug:
                        print('Big upbound, range has been split!')
                    real2 = integrate.quad((lambda x: self.numerator(x)
                                            / (self.a * (x - self.root1))),
                                           mid, right_range,
                                           weight='cauchy', wvar=self.root2)[0]
                    real2 += integrate.quad((lambda x: self.numerator(x)
                                             / (self.a*x**2 + self.b*x +
                                                self.c)),
                                            right_range, self.upper_lim)[0]

                else:
                    real2 = integrate.quad((lambda x: self.numerator(x)
                                            / (self.a * (x - self.root1))),
                                           mid, self.upper_lim,
                                           weight='cauchy', wvar=self.root2)[0]
                res = real1 + real2
                inte_metheod = 'all_root_in'
            elif self.root1_in:
                if self.debug:
                    print('root1 in 111111111111111111111')
                res = integrate.quad((lambda x: self.numerator(x)
                                      / (self.a * (x - self.root2))),
                                     self.lower_lim, self.upper_lim,
                                     weight='cauchy', wvar=self.root1)[0]
                inte_metheod = 'root1_in'
            else:
                if self.debug:
                    print('root2 in 2222222222222222')

                right_range = 2*self.root2 - self.root1
                if self.upper_lim &gt; right_range:
                    # 如果积分上限特别大, 就分段积, 要不然算法找不到 pole 的贡献.
                    if self.debug:
                        print('Big upbound, range has been split!')
                    res = integrate.quad((lambda x: self.numerator(x)
                                          / (self.a * (x - self.root1))),
                                         self.lower_lim, right_range,
                                         weight='cauchy', wvar=self.root2)[0]
                    res += integrate.quad((lambda x: self.numerator(x)
                                           / (self.a*x**2 + self.b*x +
                                              self.c)),
                                          right_range, self.upper_lim)[0]
                else:
                    res = integrate.quad((lambda x: self.numerator(x)
                                          / (self.a * (x - self.root1))),
                                         self.lower_lim, self.upper_lim,
                                         weight='cauchy', wvar=self.root2)[0]
                inte_metheod = 'root2_in'
        else:
            if self.a == 0:
                if self.debug:
                    print('a = 0 ! 000000000000')
                res = integrate.quad(lambda x: self.numerator(x)/self.b,
                                     self.lower_lim, self.upper_lim,
                                     weight='cauchy', wvar=-self.c/self.b)[0]
                inte_metheod = 'trivial'
            else:
                if self.debug:
                    print('Root Not Exist!...................')
                res = integrate.quad((lambda x: self.numerator(x)
                                      / (self.a*x**2 + self.b*x + self.c)),
                                     self.lower_lim, self.upper_lim)[0]
                inte_metheod = 'root_not_exist'
        return res, inte_metheod


def _g(x, y, muT, debug=False):
    &quot;&quot;&quot;Qi PhD Eq.(3.48)

    Parameters
    ----------
    x : float
        x
    y : float
        y
    muT : float
          μ / T
    debug : bool
            debug
    Returns
    -------
    res : float
          g
    &quot;&quot;&quot;
    a = x**2/2 + y**2/8 - muT
    b = x*y / 2
    if debug:
        print(f'a = {a:.2f}, b = {b:.2f}')
    if b == 0:
        # g = 4/(1 + np.exp(a))
        g = 4*np.exp(-a) / (np.exp(-a) + 1)
    else:
        g = np.exp(-b) + np.exp(-a)
        denominator = np.exp(-b) + np.exp(-a - 2*b)
        if denominator == 0:
            g = np.inf
        else:
            g /= denominator
        g = np.log(g)
        g *= 2/b
    return g


def _g_diff_a(x, y, muT):
    &quot;&quot;&quot;d g / d a&quot;&quot;&quot;
    a = x**2/2 + y**2/8 - muT
    b = x*y / 2
    if b == 0:
        dg = np.exp(-a)
        dg /= (np.exp(-a) + 1)**2
    else:
        dg = 1 - np.exp(-2*b)
        dg /= 1 + np.exp(-2*b) + np.exp(-a-b) + np.exp(a-b)
        dg *= -2 / b
    return dg


def Gamma_0_re(q, omega, mu, a):
    &quot;&quot;&quot; 以 T 作单位制下的 particle-partilce propagator
    Eq.(3.47)
    Real part of inverse BCS pair propagator.

    a: a_s, s-wave scattering length, in unit of temperature
    q: q / sqrt(T)
    omega: omega / T
    mu : mu / T
    &quot;&quot;&quot;

    Omega = omega + 2*mu - q**2/4

    re = -1 / (4*np.pi*a)
    pv = PrincipalValueInt(numerator=lambda x: x**2 * _g(x, q, muT=mu),
                           coeff=[1, 0, -Omega],
                           lower_lim=0, upper_lim=10).get_real()[0]
    re += pv / (4*np.pi**2)
    if Omega &lt; 0:
        re += np.sqrt(-Omega) / (4*np.pi)
    return re


def Gamma_0_im(q, omega, mu):
    &quot;&quot;&quot; 以 T 作单位制下的 particle-partilce propagator
    (3.47)
    Imaginary part of inverse BCS pair propagator.
    虚部与散射长度无关!!!!!

    a: a_s, s-wave scattering length, in unit of temperature
    q: q / sqrt(T)
    omega: omega / T
    mu : mu / T
    &quot;&quot;&quot;

    Omega = omega + 2*mu - q**2/4

    if Omega &gt; 0:
        im = np.sqrt(Omega) / (8*np.pi)
        im *= _g(np.sqrt(Omega), q, muT=mu) - 2
    else:
        im = 0
    return im


def find_muT_at_Tc(a):
    &quot;&quot;&quot;Find Tc

    use Re(0, 0, muT, aT) = 0, given a aT, return muT

    Parameters
    ----------
    a : scattering length (a_s * sqrt(T))
    Returns
    -------
    muT : float
          μ / T
    &quot;&quot;&quot;
    res = optimize.root(lambda muT: Gamma_0_re(q=0, omega=0, mu=muT, a=a), -1)
    if not res.success:
        print('IMPORTANT ERROR !!!!!!!!!! ROOT NOT FIND!!!!!!find muT!')
    muT = res.x[0]
    return muT


def find_omegaT(qT, muT, a, debug=False):
    &quot;&quot;&quot;Given aT, aT, find the dispersion curve ω_q
    a: s-wave scattering length in unit of temperature
    &quot;&quot;&quot;
    def re_qT_omegaT(omegaT, qT=qT):
        return Gamma_0_re(q=qT, omega=omegaT, mu=muT, a=a)

    if qT &gt; 1e-4:
        res = optimize.root(re_qT_omegaT, 0, options={'xtol': 1e-9})
        # 如果比较低的精度就能满足要求, 可以用比较低的精度, 来避免返回 res.success=False.
        if debug and (not res.success):
            print('Error infind omegaT, error message is:')
            print(res.message)
            print('error parameters is')
            print(f'qT={qT:.15f}, muT={muT:.15f}')
            print(f'res para={1/a:.15f}, root={res.x[0]}')
        omegaT = res.x[0]
    else:                       # 线性近似
        # TODO: 为了避免在 qT 很小时会剧烈抖动而找不到根, 采用了线性近似. 这个还是要改
        # 的. 现在去除了乘了两次 fluc 的 bug 后应该就没有这个问题了.
        omegaT = qT / (1e-4) * optimize.root((lambda omegaT:
                                                re_qT_omegaT(omegaT,
                                                            qT=1e-4)),
                                                0, options={'xtol':
                                                            1e-13}).x[0]
    return omegaT


class Density():
    &quot;&quot;&quot;Density, in unit of Temperature
    &quot;&quot;&quot;
    def __init__(self, mu, a, debug=True):
        &quot;&quot;&quot;
        mu : chemical potential in unit of temperature, μ / T
        a: s-wave scattering length in unit of temperature,
        &quot;&quot;&quot;
        self.mu = mu
        self.a = a
        self.debug = debug

    def _im_diff_mu_s(self, qT: float, omegaT: float):
        &quot;&quot;&quot;d im / d μ, (delta part has no contribution)
           验证过, 没有问题! s-wave
        &quot;&quot;&quot;
        OT = omegaT + 2*self.mu - qT**2/4
        if OT &gt; 0:
            dim = (_g(np.sqrt(OT), qT, muT=self.mu) - 2) / np.sqrt(OT)
            dim += np.sqrt(OT) * _g_diff_a(np.sqrt(OT), qT, muT=self.mu)
            dim /= 8*np.pi
            dim += - np.sqrt(OT) / (8*np.pi) * _g_diff_a(np.sqrt(OT), qT,
                                                         muT=self.mu)
        else:
            dim = 0
        return dim

    def _fluc1_dense(self, qT, omegaT):
        &quot;&quot;&quot;Eq. (3.49) and Eq. (3.49)&quot;&quot;&quot;
        real = Gamma_0_re(q=qT, omega=omegaT, mu=self.mu,
                          a=self.a)
        imag = Gamma_0_im(q=qT, omega=omegaT, mu=self.mu)

        volume_elem = (1 / np.pi) * (1 / (2*np.pi**2))

        diff_re = derivative((lambda mu: Gamma_0_re(q=qT, omega=omegaT, mu=mu,
                                                    a=self.a)),
                             self.mu, dx=.1)
        diff_im = self._im_diff_mu_s(qT, omegaT)
        fluctdens = qT**2 * bose(1, omegaT)
        fluctdens *= (imag*diff_re - real*diff_im) / (imag**2+real**2)
        res = fluctdens * volume_elem
        return res

    def _fluc1_s(self, qT, BCS):
        &quot;&quot;&quot; 计算 pair 涨落在连续激发区的贡献 &quot;&quot;&quot;
        # 实部为 0 时对应的准粒子激发
        omega_p = find_omegaT(qT=qT, muT=self.mu,
                              a=self.a)
        # print('omega p is', omega_p)

        if BCS:
            &quot;如果在 BCS 极限下的的话, 连续激发边界的边界有比较重要的贡献&quot;
            boundary = qT**2/4 - 2*self.mu  # 连续激发的边界
            # 从连续激发边界, 到准粒子激发处的贡献
            int1 = integrate.quad((lambda omega:
                                   self._fluc1_dense(qT=qT, omegaT=omega)),
                                  boundary, -2*omega_p, epsrel=1e-3, limit=40)
        else:
            int1 = [0]

        # 准粒子激发的贡献
        int3 = integrate.quad(lambda omega: self._fluc1_dense(qT=qT,
                                                              omegaT=omega),
                              -10*omega_p, 11*omega_p, epsrel=1e-3, limit=40)
        res = int1[0] + int3[0]
        return res

    def _fluc2_s(self, qT):
        &quot;&quot;&quot; use Qi PhD Eq.(3.52) at Tc
            pair 涨落的 single pole 部分.
        &quot;&quot;&quot;
        volume_elem = qT**2 / (2*np.pi**2)

        def omega_q(muT):
            return find_omegaT(qT=qT, muT=muT, a=self.a)

        diff = derivative(omega_q, self.mu, dx=.1)
        energy = omega_q(self.mu)  # qT**2/4  # - 2*muT - aT**2
        if energy &lt; qT**2/4 - 2*self.mu:
            fluc = bose(1, energy)
            fluc *= - diff
            fluc *= volume_elem
        else:
            fluc = 0
        return fluc

    def s_wave_density(self, para, debug=True):
        &quot;&quot;&quot; n / (T)^(3/2)
        Calculate the density.

        According the interaction strength, we use three different method to
        calculate the density.

        Parameters
        ----------
        muT : float
              μ / T
        aT : folat
             1 / (as * sqrt(T))
        Returns
        -------
        n : float
            density
        &quot;&quot;&quot;
        if para.method == 'SinglePole_StrongBEC':
            &quot;&quot;&quot;
            method [1]: SinglePole_StrongBEC.
            In Strong BEC limit, the density are mainly contributed by the
            dimers formed by two Fermion.

            Mathematica code:
            Integrate[q^2/(Exp[q^2/4]-1),{q,0,Infinity}]
            &gt;&gt; 2 Sqrt[\[Pi]] Zeta[3/2]
            &quot;&quot;&quot;
            n = 4*np.sqrt(np.pi)*zeta(3/2)

        elif para.method == 'SinglePole':
            &quot;&quot;&quot;
            method [2]: SinglePole.
            准粒子激发在 q=0 时, ω(q)=0. 因此, 在 μ&lt;0 时, 准粒子激发完
            全位于连续激发外, 是孤立的奇点. 此时, 考虑自由费米子(几乎可以忽略) 和 Single
            Pole 的 pair 涨落的贡献.
            &quot;&quot;&quot;
            n_fluc2 = integrate.quad(self._fluc2_s, 0, para.n_fluc2_up,
                                     epsrel=para.n_fluc2_epsrel)
            # 此处也用较低的精度即可. 接近 0 时平滑地走近于一个常数. TODO: 动量积分的下限
            # 做了近似, 0 处有bug
            n_fluc = n_fluc2[0]
            n_free = free_fermion_density(self.mu)
            n = n_free + n_fluc
            # print('*************', n_fxluc, n_free)
        elif para.method == 'NSR':
            &quot;&quot;&quot;
            method [3]: NSR.
            在 μ&gt;0 时, 准粒子激发几乎位于连续激发内, 在低动量低频率区有尖锐的
            准粒子峰贡献.
            BEC Unitary侧, 考虑自由费米子 和 pair 涨落(连续激发).&quot;&quot;&quot;
            n_fluc1 = integrate.quad((lambda qT:
                                      self._fluc1_s(qT, BCS=para.fluc1_BCS)),
                                     para.n_fluc1_a, para.n_fluc1_b,
                                     epsrel=para.n_fluc1_epsrel,
                                     limit=para.n_fluc1_limit)
            n_fluc = n_fluc1[0]
            n_free = free_fermion_density(self.mu)
            n = n_free + n_fluc
        return n


def plot_Tc(aT, para, debug=False):
    &quot;&quot;&quot;
    aT : scattering length in unit of temperature
    &quot;&quot;&quot;
    muT = []
    density_T = []
    for aTi in aT:
        print('Calculating the results for point a_s*sqrt(T)=',
              aTi, ' START!')
        muTi = find_muT_at_Tc(a=1/aTi)
        muT.append(muTi)
        density_T.append(Density(mu=muTi, a=1/aTi).s_wave_density(para))
        print('Calculating the results for point a_s*sqrt(T)=',
              aTi, ' FINISH!')

    n_T = np.array(density_T)  # density in unit of temperature
    kF = (3*np.pi**2*n_T) ** (1/3)  # Fermi momentum in unit of temperature
    EF = kF**2 / 2  # Fermi energy in unit of temperature
    kfas = aT / kF  # 1 / (k_F * a_s)
    Tc_EF = 1 / EF
    plt.plot(kfas, Tc_EF, 'o', label=&quot;This numerical program&quot;)


def plot_paper():
    &quot;&quot;&quot;
    The data from the published papers.
    &quot;&quot;&quot;
    paper_data = np.array([[-1.99903, 0.016667],
                           [-1.59262, 0.034058],
                           [-1.30582, 0.052899],
                           [-0.98741, 0.084058],
                           [-0.73053, 0.119565],
                           [-0.47717, 0.16087],
                           [-0.21622, 0.2],
                           [-0.0841, 0.214493],
                           [0.0013, 0.222464],
                           [0.10593, 0.228986],
                           [0.22578, 0.231884],
                           [0.35702, 0.231159],
                           [0.4381, 0.231159],
                           [0.56522, 0.226087],
                           [0.68084, 0.222464],
                           [0.83905, 0.221014],
                           [1.02812, 0.218841],
                           [1.19024, 0.218116],
                           [1.3524, 0.218116],
                           [1.41418, 0.218116]
                           ])
    t_star = np.array([[-1.99602, 0.029288],
                       [-1.76099, 0.038028],
                       [-1.53813, 0.052065],
                       [-1.33351, 0.070343],
                       [-1.09651, 0.102372],
                       [-0.86968, 0.147815],
                       [-0.62669, 0.217954],
                       [-0.48093, 0.271542],
                       [-0.26232, 0.365333]
                       ])
    plt.plot(paper_data[:, 0], paper_data[:, 1],
             label='results from published papers')
    plt.plot(t_star[:, 0], t_star[:, 1], '--')


class Para():
    &quot;&quot;&quot; 指定一些数值计算中需要调的参数.
    &quot;&quot;&quot;
    def __init__(self, method: str, n_fluc2_up,
                 n_fluc2_limit, n_fluc2_epsrel,
                 n_fluc1_a, n_fluc1_b, n_fluc1_limit, n_fluc1_epsrel,
                 fluc1_BCS):
        &quot;&quot;&quot;
        Parameters
        method : the method to be used when calculate the density.
                 There are three method can be use:
                 'SinglePole_StrongBEC', 'SinglePole', 'NSR'
        fluc1_BCS: bool
                 如果在 BCS 极限下的的话, 连续激发边界的边界有比较重要的贡献.
        &quot;&quot;&quot;
        self.method = method

        self.n_fluc2_up = n_fluc2_up
        self.n_fluc2_limit = n_fluc2_limit
        self.n_fluc2_epsrel = n_fluc2_epsrel

        self.n_fluc1_a = n_fluc1_a
        self.n_fluc1_b = n_fluc1_b
        self.n_fluc1_limit = n_fluc1_limit
        self.n_fluc1_epsrel = n_fluc1_epsrel

        self.fluc1_BCS = fluc1_BCS


def runscp():
    # ============ Single pole 近似下, aT 取 1.5~4 (取 10 个点)是可以的. ==========
    paraSinglePole = Para(method=&quot;SinglePole&quot;,
                              n_fluc2_limit=10,
                              n_fluc2_up=10,
                              n_fluc2_epsrel=1e-2,
                              n_fluc1_a=2e-2, n_fluc1_b=10,
                              n_fluc1_limit=5, n_fluc1_epsrel=1e-3,
                              fluc1_BCS=False)
    plot_Tc(aT=[1.5, 2, 3, 4], para=paraSinglePole, debug=True)

    paraNSR = Para(method=&quot;NSR&quot;,
                   n_fluc2_limit=10,
                   n_fluc2_up=10,
                   n_fluc2_epsrel=1e-2,
                   n_fluc1_a=2e-2, n_fluc1_b=10,
                   n_fluc1_limit=5, n_fluc1_epsrel=1e-3,
                   fluc1_BCS=False)
    # plot_Tc(aT=[.1, .3, 0.5, 0.8, 1.0], para=paraNSR, debug=True)
    plot_Tc(aT=[0.1, 0.3], para=paraNSR, debug=True)

    paraNSR_BCS = Para(method=&quot;NSR&quot;,
                       n_fluc2_limit=10,
                       n_fluc2_up=10,
                       n_fluc2_epsrel=1e-2,
                       n_fluc1_a=2e-2, n_fluc1_b=10,
                       n_fluc1_limit=10, n_fluc1_epsrel=1e-3,
                       fluc1_BCS=True)
    # plot_Tc(aT=[-5, -3, -1], para=paraNSR_BCS, debug=True)
    plot_Tc(aT=[-.5, -.1], para=paraNSR_BCS, debug=True)
    # plot_Tc(aT=[-5], para=paraNSR_BCS, debug=True)

    plot_paper()
    plt.xlabel(r'$1/(k_F a_s)$')
    plt.ylabel(r'$T_C / \epsilon_F$')
    plt.legend()
    plt.show()


runscp()

</code></pre><pre>Calculating the results for point a_s*sqrt(T)= 1.5  START!
</pre>
<pre>/var/folders/51/4rnfl9_93gv1fhpymn1lsz_r0000gn/T/ipykernel_37194/4289401143.py:419: DeprecationWarning: scipy.misc.derivative is deprecated in SciPy v1.10.0; and will be completely removed in SciPy v1.12.0. You may consider using findiff: https://github.com/maroba/findiff or numdifftools: https://github.com/pbrod/numdifftools
  diff = derivative(omega_q, self.mu, dx=.1)
</pre>
<pre>Calculating the results for point a_s*sqrt(T)= 1.5  FINISH!
Calculating the results for point a_s*sqrt(T)= 2  START!
Calculating the results for point a_s*sqrt(T)= 2  FINISH!
Calculating the results for point a_s*sqrt(T)= 3  START!
Calculating the results for point a_s*sqrt(T)= 3  FINISH!
Calculating the results for point a_s*sqrt(T)= 4  START!
Calculating the results for point a_s*sqrt(T)= 4  FINISH!
Calculating the results for point a_s*sqrt(T)= 0.1  START!
</pre>
<pre>/var/folders/51/4rnfl9_93gv1fhpymn1lsz_r0000gn/T/ipykernel_37194/4289401143.py:377: DeprecationWarning: scipy.misc.derivative is deprecated in SciPy v1.10.0; and will be completely removed in SciPy v1.12.0. You may consider using findiff: https://github.com/maroba/findiff or numdifftools: https://github.com/pbrod/numdifftools
  diff_re = derivative((lambda mu: Gamma_0_re(q=qT, omega=omegaT, mu=mu,
/var/folders/51/4rnfl9_93gv1fhpymn1lsz_r0000gn/T/ipykernel_37194/4289401143.py:404: IntegrationWarning: The integral is probably divergent, or slowly convergent.
  int3 = integrate.quad(lambda omega: self._fluc1_dense(qT=qT,
/var/folders/51/4rnfl9_93gv1fhpymn1lsz_r0000gn/T/ipykernel_37194/4289401143.py:404: IntegrationWarning: The maximum number of subdivisions (40) has been achieved.
  If increasing the limit yields no improvement it is advised to analyze 
  the integrand in order to determine the difficulties.  If the position of a 
  local difficulty can be determined (singularity, discontinuity) one will 
  probably gain from splitting up the interval and calling the integrator 
  on the subranges.  Perhaps a special-purpose integrator should be used.
  int3 = integrate.quad(lambda omega: self._fluc1_dense(qT=qT,
/var/folders/51/4rnfl9_93gv1fhpymn1lsz_r0000gn/T/ipykernel_37194/4289401143.py:480: IntegrationWarning: The maximum number of subdivisions (5) has been achieved.
  If increasing the limit yields no improvement it is advised to analyze 
  the integrand in order to determine the difficulties.  If the position of a 
  local difficulty can be determined (singularity, discontinuity) one will 
  probably gain from splitting up the interval and calling the integrator 
  on the subranges.  Perhaps a special-purpose integrator should be used.
  n_fluc1 = integrate.quad((lambda qT:
</pre>
<pre>Calculating the results for point a_s*sqrt(T)= 0.1  FINISH!
Calculating the results for point a_s*sqrt(T)= 0.3  START!
Calculating the results for point a_s*sqrt(T)= 0.3  FINISH!
Calculating the results for point a_s*sqrt(T)= -0.5  START!
</pre>
<pre>/var/folders/51/4rnfl9_93gv1fhpymn1lsz_r0000gn/T/ipykernel_37194/4289401143.py:480: IntegrationWarning: The maximum number of subdivisions (10) has been achieved.
  If increasing the limit yields no improvement it is advised to analyze 
  the integrand in order to determine the difficulties.  If the position of a 
  local difficulty can be determined (singularity, discontinuity) one will 
  probably gain from splitting up the interval and calling the integrator 
  on the subranges.  Perhaps a special-purpose integrator should be used.
  n_fluc1 = integrate.quad((lambda qT:
</pre>
<pre>Calculating the results for point a_s*sqrt(T)= -0.5  FINISH!
Calculating the results for point a_s*sqrt(T)= -0.1  START!
Calculating the results for point a_s*sqrt(T)= -0.1  FINISH!
</pre>
<pre>&lt;Figure size 640x480 with 1 Axes&gt;</pre><img src="data:image/png;base64,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O3GCC8uWEf/oY5zscw+pc94mb0cMlJRg3bwZ7i+MJfCHH2gWvQWvmW/i0KuX3PElGhxFUTDk55vkUdXVilatWoWVlRXbt29n2bJlZGZmcu+999KxY0f27NlDZGQkqampDB06FIDk5GSGDx/OM888w9GjR4mOjmbw4MFVPu4Vu3fvBmDFihUkJycbXz/55JM0btyY3bt3s3fvXl599dUKW3N2795N//79GTp0KMnJyXzwwQfG92bNmsUjjzzCP//8wzPPPMMvv/zCpEmTeOWVVzh06BBjx45l9OjRbNmypUydc+bMYcSIEcTGxtKqVSueeOIJxo4dy4wZM9izZw+KojB+/Pibnt/UqVN55ZVX2L9/Pz169OChhx4iIyOjStfo5MmTfP/99/z2229ERkayf/9+xo0bV6l99+zZw8SJE3nrrbeIi4sjMjKSu+++u0yZVatWYW9vz86dO1mwYAFvvfUWmzZtMr7/2GOPkZaWxsaNG9m7dy+dOnWib9++XLx4EYDvv/+eWbNm8e6777Jnzx68vb355JNPKhXf1KlTef/999m9ezeNGjXioYceovjyHcSFhYWEhISwfv16Dh06xJgxY3j66afZtWvXdfFbWFiwa9cuPvjgAxYtWsQXX3xhfH/8+PHExMSwZs0aDh48yGOPPUb//v05ceKEsUx+fj7z58/niy++4PDhw7i5uTFo0CB69+7NwYMHiYmJYcyYMTU7kbAiKpSVlaUASlZWVq0f21BSouTt3aukzF+gnOjXTznSstW/j1atlfjhTygXvviPoouPr/XYhDAHBQUFypEjR5SCggLjNn1eXtn/K7X40OflVTr23r17Kx07diyzbc6cOUq/fv3KbDt37pwCKHFxccrevXsVQDlz5kyFdU6aNKnMtoEDByojR440vg4ICFAWL15sfA0ov/zyS5l9HB0dlZUrV1b6XK49xpV6J0+eXGZbz549leeff77Mtscee0x54IEHyuz3xhtvGF/HxMQogPKf//zHuO27775TbGxsKownPj5eAZR58+YZtxUXFyuNGzdW5s+fryiKoqxYsUJxdnYus98vv/yiXP2VGBERoWg0GiUxMdG4bePGjYparVaSk5MVRVGUkSNHKgMHDjS+f/XP4KefflKcnJyU7OzscuPs3bu3cuedd5bZ1qVLF2X69OmKoijKtm3bFCcnJ6WwsLBMmaZNmyrLly9XFEVRevTooYwbN67M+926dVM6dOhQ7jEVRVG2bNmiAMqaNWuM2zIyMhRbW1tl7dq1Fe43YMAA5ZVXXikTf+vWrRWDwWDcNn36dKV169aKoijK2bNnFY1Go5w/f75MPX379lVmzJihKErpzwFQYmNjy8QCKNHR0RXGckV5nwFXVOX7W8YImRGDTkfejh3kREWRuyUa/VV/vaisrLDv0aN0WYt77sHCo+ZnmhZC1JyQkJAyrw8cOMCWLVtwKGfi0lOnTtGvXz/69u1Lu3btCAsLo1+/fjz66KO4urpWa1zh4eE899xzrF69mtDQUB577DGaNm1a5Xo6d+5c5vXRo0cZM2ZMmW29evUq04oE0L59e+NzrVYLQLt27cpsKywsJDs7+4aLafbo0cP43MLCgs6dO3P06NEqnYO/vz++vr5l6jQYDMTFxeHl5XXDfe+77z4CAgJo0qQJ/fv3p3///jzyyCPY2dkZy1x9rgDe3t6kpaUBpb8Pubm5uLu7lylTUFBg7Bo8evQoL7zwQpn3e/TocV0rW3muvj5ubm60bNnSeH30ej3vvvsu33//PefPn6eoqAidTlcmdoDu3buXaanp0aMH77//Pnq9nn/++Qe9Xk+LFi3K7KPT6cqck5WVVZnr4ObmxqhRowgLC+O+++4jNDSUoUOH4u3tfdNzulWSCJmYPiuL3P/7P3I2R5H7v/+hXD3Y2ckJhz69cby3L/Z33injfIS4CZWtLS337TXZsavC3r7s/+fc3Fweeugh5s+ff11Zb29vNBoNmzZtYseOHfz555989NFHvP766+zcuZOgoCDUavV13WTFV02WWlmzZs3iiSeeYP369WzcuJGIiAjWrFnDI488clvnV1lXd8Nd+ZItb5vBYLil+oFqu1Y34ujoyL59+4iOjubPP/9k5syZzJo1i927dxvHJ13b5ahSqYznlZubi7e3d5kxNVfU9DQF7733Hh988AFLliyhXbt22NvbM3nyZIqKiipdR25uLhqNhr1796LRaMq8d3Wyb2t7/fqZK1asYOLEiURGRrJ27VreeOMNNm3aRPfu3W/vxCogiZAJ6DMzyfp9PTlRm8nftRv0euN7Fl5expXc7Tp3RtUA7rQQorqoVCpU1/zVWld06tSJn376icDAQCwsyv9oVqlU9OrVi169ejFz5kwCAgL45ZdfCA8Pp1GjRiQnJxvL6vV6Dh06xD333FPhMS0tLdFf9flzRYsWLWjRogUvv/wyw4cPZ8WKFVVOhK7VunVrtm/fzsiRI43btm/fTps2bW6r3or8/fffxjE5JSUl7N271zi2qFGjRuTk5JCXl2dM2GJjY6+rIyEhgaSkJHx8fIx1qtVqWrZsWakYLCwsCA0NJTQ0lIiICFxcXPjrr78YPHjwTfft1KkTKSkpWFhYGAeyX6t169bs3LmTESNGlDnvyvj777/x9/cH4NKlSxw/fpzWrVsDpT+XgQMH8tRTTwGlSefx48ev+1nt3LnzujqbN2+ORqOhY8eO6PV60tLSuOuuuyoV09U6duxIx44dmTFjBj169ODbb7+VRKg+0efkkPr228bX1s2bX17JPRSbO9rUyuryQgjz8tJLL/H5558zfPhw451EJ0+eZM2aNXzxxRfs2bOHqKgo+vXrh6enJzt37iQ9Pd345XXvvfcSHh7O+vXradq0KYsWLSIzM/OGxwwMDCQqKopevXphbW2NjY0NU6dO5dFHHyUoKIjExER2797NkCFDbvv8pk6dytChQ+nYsSOhoaH89ttv/Pzzz2zevPm26y7P0qVLad68Oa1bt2bx4sVcunSJZ555BoBu3bphZ2fHa6+9xsSJE9m5cycrV668rg4bGxtGjhzJwoULyc7OZuLEiQwdOvSm3WIAv//+O6dPn+buu+/G1dWVDRs2YDAYKp1EhYaG0qNHDwYNGsSCBQto0aIFSUlJrF+/nkceeYTOnTszadIkRo0aRefOnenVqxfffPMNhw8fpkmTJjet/6233sLd3R2tVsvrr7+Oh4eHcT6p5s2b8+OPP7Jjxw5cXV1ZtGgRqamp1yVCCQkJhIeHM3bsWPbt28dHH33E+++/D5Qm008++SQjRozg/fffp2PHjqSnpxMVFUX79u0ZMGBAuXHFx8fz2Wef8fDDD+Pj40NcXBwnTpwok+xVN0mETMDKzw/nRx7BunlzHPvei1VAgKlDEkKYmI+PD9u3b2f69On069cPnU5HQEAA/fv3R61W4+TkxNatW1myZAnZ2dkEBATw/vvvc//99wPwzDPPcODAAUaMGIGFhQUvv/zyDVuDAN5//33Cw8P5/PPP8fX15fjx42RkZDBixAhSU1Px8PBg8ODBzJ49+7bPb9CgQXzwwQcsXLiQSZMmERQUxIoVK+jTp89t112eefPmMW/ePGJjY2nWrBn//e9/8bg8ttLNzY2vv/6aqVOn8vnnn9O3b19mzZp13RimZs2aMXjwYB544AEuXrzIgw8+WOm7slxcXPj555+ZNWsWhYWFNG/enO+++4477rijUvurVCo2bNjA66+/zujRo0lPT8fLy4u7777bOHZq2LBhnDp1imnTplFYWMiQIUN48cUX+eOPPyp1fSZNmsSJEycIDg7mt99+M85l9cYbb3D69GnCwsKws7NjzJgxDBo06LqpA0aMGEFBQQFdu3ZFo9EwadKkMtdwxYoVvP3227zyyiucP38eDw8PunfvzoMPPlhhXHZ2dhw7doxVq1aRkZGBt7c3L730EmPHjq3UdbsVKuXajlJhlJ2djbOzM1lZWTcclCeEqH2FhYXEx8cTFBSEjY2NqcMRZuLMmTMEBQWxf/9+WWqiHNHR0dxzzz1cunTptsYa9enTh+Dg4GpfsqUqbvQZUJXvb5lHSAghhBANliRCQgghhGiwZIyQEEKIeiMwMPCWZ9tuCPr06VMt16e82/rrKmkREkIIIUSDJYmQEEIIIRosSYSEEHXa7cwwLISou6qrC1TGCAkh6iQrKyvUajVJSUk0atQIKysrmYxUiAZCURTS09NRqVTXLVVSVZIICSHqJLVaTVBQEMnJySQlJZk6HCFELVOpVDRu3Pi6tcyqShIhIUSdZWVlhb+/PyUlJeWumSWEqL8sLS1vOwkCM0uEli5dynvvvUdKSgodOnTgo48+omvXrhWW/+GHH3jzzTc5c+YMzZs3Z/78+TzwwAPG9xVFISIigs8//5zMzEx69erFp59+SvPmzWvjdIQQteBK0/jtNo8LIRomsxksvXbtWsLDw4mIiGDfvn106NCBsLAw0tLSyi2/Y8cOhg8fzrPPPsv+/fsZNGgQgwYN4tChQ8YyCxYs4MMPP2TZsmXs3LkTe3t7wsLCKCwsrK3TEkIIIYQZM5u1xrp160aXLl34+OOPgdI7Qfz8/JgwYQKvvvrqdeWHDRtGXl4ev//+u3Fb9+7dCQ4OZtmyZSiKgo+PD6+88gpTpkwBICsrC61Wy8qVK3n88cdvGpOsNSaEEELUPXVurbGioiL27t1LaGiocZtarSY0NJSYmJhy94mJiSlTHiAsLMxYPj4+npSUlDJlnJ2d6datW4V1CiGEEKJhMYsxQhcuXECv16PVasts12q1HDt2rNx9UlJSyi2fkpJifP/KtorKXEun06HT6Yyvs7KygNLMUgghhBB1w5Xv7cp0eplFImQu5s6dy+zZs6/b7ufnZ4JohBBCCHE7cnJycHZ2vmEZs0iEPDw80Gg0pKamltmempqKl5dXuft4eXndsPyVf1NTU/H29i5TJjg4uNw6Z8yYQXh4uPG1wWDg4sWLuLu7V/tEbdnZ2fj5+XHu3LkGPf5IrkMpuQ6l5DqUkutQSq5DKbkOpapyHRRFIScnBx8fn5vWaxaJkJWVFSEhIURFRTFo0CCgNAmJiopi/Pjx5e7To0cPoqKimDx5snHbpk2b6NGjBwBBQUF4eXkRFRVlTHyys7PZuXMnL774Yrl1WltbY21tXWabi4vLbZ3bzTg5OTXoX+wr5DqUkutQSq5DKbkOpeQ6lJLrUKqy1+FmLUFXmEUiBBAeHs7IkSPp3LkzXbt2ZcmSJeTl5TF69GgARowYga+vL3PnzgVg0qRJ9O7dm/fff58BAwawZs0a9uzZw2effQaUzi0yefJk3n77bZo3b05QUBBvvvkmPj4+xmRLCCGEEA2b2SRCw4YNIz09nZkzZ5KSkkJwcDCRkZHGwc4JCQmo1f/e5NazZ0++/fZb3njjDV577TWaN2/OunXraNu2rbHMtGnTyMvLY8yYMWRmZnLnnXcSGRmJjY1NrZ+fEEIIIcyP2SRCAOPHj6+wKyw6Ovq6bY899hiPPfZYhfWpVCreeust3nrrreoKsdpYW1sTERFxXVdcQyPXoZRch1JyHUrJdSgl16GUXIdSNXUdzGZCRSGEEEKI2mYWEyoKIYQQQpiCJEJCCCGEaLAkERJCCCFEgyWJkBBCCCEaLEmEasmZM2d49tlnCQoKwtbWlqZNmxIREUFRUdEN9yssLOSll17C3d0dBwcHhgwZct2M2nXNO++8Q8+ePbGzs6v0hJWjRo1CpVKVefTv379mA61ht3IdFEVh5syZeHt7Y2trS2hoKCdOnKjZQGvYxYsXefLJJ3FycsLFxYVnn32W3NzcG+7Tp0+f634fXnjhhVqKuHosXbqUwMBAbGxs6NatG7t27bph+R9++IFWrVphY2NDu3bt2LBhQy1FWrOqch1Wrlx53c+9PkyHsnXrVh566CF8fHxQqVSsW7fupvtER0fTqVMnrK2tadasGStXrqzxOGtaVa9DdHT0db8PKpWqwvVEKyKJUC05duwYBoOB5cuXc/jwYRYvXsyyZct47bXXbrjfyy+/zG+//cYPP/zA//3f/5GUlMTgwYNrKeqaUVRUxGOPPVbhDN8V6d+/P8nJycbHd999V0MR1o5buQ4LFizgww8/ZNmyZezcuRN7e3vCwsIoLCyswUhr1pNPPsnhw4fZtGkTv//+O1u3bmXMmDE33e/5558v8/uwYMGCWoi2eqxdu5bw8HAiIiLYt28fHTp0ICwsjLS0tHLL79ixg+HDh/Pss8+yf/9+Bg0axKBBgzh06FAtR169qnodoHRW4at/7mfPnq3FiGtGXl4eHTp0YOnSpZUqHx8fz4ABA7jnnnuIjY1l8uTJPPfcc/zxxx81HGnNqup1uCIuLq7M74Snp2fVDqwIk1mwYIESFBRU4fuZmZmKpaWl8sMPPxi3HT16VAGUmJiY2gixRq1YsUJxdnauVNmRI0cqAwcOrNF4TKWy18FgMCheXl7Ke++9Z9yWmZmpWFtbK999910NRlhzjhw5ogDK7t27jds2btyoqFQq5fz58xXu17t3b2XSpEm1EGHN6Nq1q/LSSy8ZX+v1esXHx0eZO3duueWHDh2qDBgwoMy2bt26KWPHjq3ROGtaVa9DVT4z6ipA+eWXX25YZtq0acodd9xRZtuwYcOUsLCwGoysdlXmOmzZskUBlEuXLt3WsaRFyISysrJwc3Or8P29e/dSXFxMaGiocVurVq3w9/cnJiamNkI0K9HR0Xh6etKyZUtefPFFMjIyTB1SrYqPjyclJaXM74OzszPdunWrs78PMTExuLi40LlzZ+O20NBQ1Go1O3fuvOG+33zzDR4eHrRt25YZM2aQn59f0+FWi6KiIvbu3Vvm56hWqwkNDa3w5xgTE1OmPEBYWFid/bnDrV0HgNzcXAICAvDz82PgwIEcPny4NsI1K/Xx9+F2BAcH4+3tzX333cf27durvL9ZzSzdkJw8eZKPPvqIhQsXVlgmJSUFKyur68aPaLXaKveB1nX9+/dn8ODBBAUFcerUKV577TXuv/9+YmJi0Gg0pg6vVlz5mV9ZduaKuvz7kJKScl0ztoWFBW5ubjc8pyeeeIKAgAB8fHw4ePAg06dPJy4ujp9//rmmQ75tFy5cQK/Xl/tzPHbsWLn7pKSk1KufO9zadWjZsiVffvkl7du3Jysri4ULF9KzZ08OHz5M48aNayNss1DR70N2djYFBQXY2tqaKLLa5e3tzbJly+jcuTM6nY4vvviCPn36sHPnTjp16lTpeqRF6Da9+uqr5Q7Wuvpx7X/q8+fP079/fx577DGef/55E0VevW7lOlTF448/zsMPP0y7du0YNGgQv//+O7t37y536RVTqunrUFfU9HUYM2YMYWFhtGvXjieffJKvvvqKX375hVOnTlXjWQhz06NHD0aMGEFwcDC9e/fm559/plGjRixfvtzUoYn/b+/eY5o6/zCAPwVK0TmDWKRD4wVkdXihpYGtDZEZNp0u1amZwh8ELxEvWTKzCXGZm9Ho5m6YxRF3c5hl2YzLNi5jmc5itjEcBqRKlRDRigEn2RCUTRgMv/uDnyeriFJoKfz6fJIm8J5vz3nfl7Z5eM854AN6vR7r16+HyWSCxWLBJ598AovFgr1797q1H64IDdKLL76IVatW3bMmKipK+frKlSuYN28eLBYLPvzww3s+T6fTobOzE62trS6rQk1NTdDpdIPptse5Ow+DFRUVBa1Wi7q6OqSkpHhsv4PlzXm4/TNvamrCQw89pLQ3NTXBYDAMaJ/e0t950Ol0vS6M/eeff3Dt2jW3XuOPPvoogJ6V1ujoaLf7O5S0Wi0CAwN73f15r/e1Tqdzq34kGMg83EmtVsNoNKKurs4bXRy2+no9jB071m9Wg/qSmJiI0tJSt57DIDRI4eHhCA8P71dtY2Mj5s2bB5PJhLy8PAQE3HtBzmQyQa1Ww2azYfny5QB6ro6/fPkyzGbzoPvuSe7Mgyc0NDSgubnZJRAMB96ch2nTpkGn08FmsynB58aNGygvL3f7Djxv6+88mM1mtLa2orKyEiaTCQBQUlKCW7duKeGmP+x2OwAMu9fD3QQHB8NkMsFms+GZZ54BANy6dQs2m63PfzptNpths9mwefNmpe2HH34Ydp8D7hjIPNypu7sb1dXVWLRokRd7OvyYzeZefz5hpL8ePMVut7v/OTCoS62p3xoaGmT69OmSkpIiDQ0N8ttvvymP/9bo9XopLy9X2jZs2CCTJ0+WkpISqaioELPZLGaz2RdD8Jj6+nqpqqqSHTt2yJgxY6Sqqkqqqqqkra1NqdHr9fL111+LiEhbW5ts2bJFTpw4IU6nU44dOybx8fESExMjHR0dvhrGoLk7DyIie/bskdDQUCkoKJAzZ87IkiVLZNq0adLe3u6LIXjEU089JUajUcrLy6W0tFRiYmIkLS1N2X7n+6Kurk527twpFRUV4nQ6paCgQKKiomTu3Lm+GoLbDh06JBqNRg4ePCjnzp2TzMxMCQ0NlatXr4qISHp6umzdulWp/+WXXyQoKEjefvttqampke3bt4tarZbq6mpfDcEj3J2HHTt2yJEjR+TChQtSWVkpqampEhISImfPnvXVEDyira1Nef8DkJycHKmqqpL6+noREdm6daukp6cr9RcvXpTRo0dLVlaW1NTUSG5urgQGBsr333/vqyF4hLvzsHfvXsnPz5fz589LdXW1PP/88xIQECDHjh1z67gMQkMkLy9PANz1cZvT6RQAcvz4caWtvb1dNm3aJOPGjZPRo0fL0qVLXcLTSJSRkXHXefjvuAFIXl6eiIjcvHlT5s+fL+Hh4aJWq2XKlCmybt065cNypHJ3HkR6bqF/5ZVXJCIiQjQajaSkpEhtbe3Qd96DmpubJS0tTcaMGSNjx46V1atXu4TBO98Xly9flrlz50pYWJhoNBqZPn26ZGVlyfXr1300goHZt2+fTJ48WYKDgyUxMVF+/fVXZVtycrJkZGS41B8+fFgefvhhCQ4OlpkzZ0pxcfEQ99g73JmHzZs3K7URERGyaNEiOXXqlA967Vm3bwO/83F77BkZGZKcnNzrOQaDQYKDgyUqKsrlc2Kkcnce3njjDYmOjpaQkBAJCwuTxx9/XEpKStw+rkpEZGALUEREREQjG+8aIyIiIr/FIERERER+i0GIiIiI/BaDEBEREfktBiEiIiLyWwxCRERE5LcYhIiIiMhvMQgRERGR32IQIiIiIr/FIERE/3eam5sxYcIEXLp0SWnbsmWL8s89vS01NRXvvPPOkByLiAaHQYiIhq2ffvoJVqsVkZGRUKlUyM/Pv2vd6tWrsW3bNuX73bt3Y8mSJZg6darSZrfbYTAYvNvh/9m2bRt2796N69evD8nxiGjgGISIaNj666+/EBcXh9zc3D5ruru78e2332Lx4sUAgJs3b+LAgQNYu3atS93p06eHLAjNmjUL0dHR+Oyzz4bkeEQ0cAxCRDRsLVy4ELt27cLSpUv7rCkrK4NarUZCQgIA4LvvvoNGo8Fjjz2m1DQ0NOCPP/5QglBrayusViuSkpJw9erVe/Zh+/btmD17Nh544AFERERg48aN6Orqum/frVYrDh061I9REpEvMQgR0YhWWFgIq9UKlUoFAPj5559hMplcaux2O0JDQzF16lRUV1cjISEBEydOxPHjx6HT6frct4hARPDBBx/g3LlzOHjwIL766it8/PHH9+1XYmIiTp48ib///ntwAyQir2IQIqIRraCgQDktBgD19fWIjIx0qbHb7YiLi8Pnn3+O5ORkZGdn4/3334darQYA5OTkYNKkSTAYDDAYDHj55ZcBACqVCjt37oTFYsGUKVOwcOFCPPHEE6itrb1vvyIjI9HZ2XnfFSci8q0gX3eAiGigampqcOXKFaSkpCht7e3tCAkJcamz2+04c+YMnnvuORQXF8NsNrtsdzgcePfdd7F8+XKX9vr6erz55pv48ccf0djYiK6uLnR0dGDPnj337duoUaMA9FyzRETDF1eEiGjEKiwsxJNPPukSfLRaLVpaWlzq7HY7li1bho6ODrS2tvbaj8Ph6HUh9e+//46EhAQ0NzcjJycHpaWlKCsrQ0BAAOLi4pS6jz76CPHx8Zg1axZWrlyptF+7dg0AEB4e7oGREpG3cEWIiEasgoICZGZmurQZjUaXu7Xa2tpw8eJFfPnll7BYLEhNTUVZWRlmzpwJoOc6oNraWmU1aM6cOfj0009RVFSE7u5ufPHFF8r1R++99x66urqU0NTS0oLc3FxUVlYiMDDQJWQ5HA5MmjQJWq3WizNARIPFIEREw9aff/6Juro65Xun0wm73Y6wsDCEhISgoqIChYWFLs9ZsGABXnrpJbS0tGDcuHE4ffo0AgMDERsbC6PRCIfDAavVipMnT0Kr1cLpdCI2NhYnTpxw2c/48eNx48YNFBYWIjY2FkVFRXj99dcxceJEZZUnKCgILS0tyM7Oxpo1a5RwBfRctD1//nwvzg4ReQJPjRHRsFVRUQGj0Qij0QgAeOGFF2A0GvHqq6+iqKgIiYmJvVZcZs+ejfj4eBw+fBhAz2mxGTNmQKPRAADeeust6PV6LFu2DJ2dnXA4HHjkkUd6HdtqtWLt2rVIT09HUlISGhsbsWLFCpdTaA8++KByWm3FihXKH3zs6OhAfn4+1q1b54VZISJPUomI+LoTRETuWrx4MZKSkpCdnd1rW3FxMbKysuBwOBAQcO/f91577TWo1WpkZWW53Yfz588jJiYGALBp0yYkJydj5cqV2L9/P7755hscPXrU7X0S0dDiihARjUhJSUlIS0u767ann34amZmZaGxsvO9++loR6o9du3ZBr9fDaDRCpVLh2WefBQCo1Wrs27dvQPskoqHFFSEiIiLyW1wRIiIiIr/FIERERER+i0GIiIiI/BaDEBEREfktBiEiIiLyWwxCRERE5LcYhIiIiMhvMQgRERGR32IQIiIiIr/FIERERER+i0GIiIiI/BaDEBEREfmtfwFo6R4pfL2N2gAAAABJRU5ErkJggg=="/>
</section>

<section class="post-meta">
    <p>标签:
        <a class="post-link" href="/tag/nsr.html">NSR</a>
        <a class="post-link" href="/tag/s-wave.html">s-wave</a>
        <a class="post-link" href="/tag/bec-bcs-crossover.html">BEC-BCS crossover</a>
    </p>
</section>

    </main>
    <footer>© 2018 - 2025 ZQW</footer>
  </div>
</body>

</html>