<!DOCTYPE html>
<html lang="zh_cn">

<head>
    <title>从冰上的水 - C 中的指针与动态内存分配</title>
  <meta charset="utf-8" />
  <meta name="generator" content="Pelican" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link
    href="https://zqw.ink/feeds/all.atom.xml"
    type="application/atom+xml" rel="alternate" title="从冰上的水 Full Atom Feed" />
  <link
    href="https://zqw.ink/feeds/ruan-jian-shi-yong.atom.xml"
    type="application/atom+xml" rel="alternate" title="从冰上的水 Categories Atom Feed" />
  <link rel="stylesheet" type="text/css" href="https://zqw.ink/theme/css/style.css" />
  <!-- fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Long+Cang&family=Noto+Serif+SC&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.6.1/github-markdown.min.css" integrity="sha512-wpdV3v8V8vWajD1kH8rI1UO1H2q9TQ3s8o1mG7lH8fS1dZ+3q1B1p4lH2tF8rQm2u0n8oV6rN3tV4nQWmY4nTw==" crossorigin="anonymous" referrerpolicy="no-referrer">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer">
  <!--fonts end  -->
  <!-- highlight.js -->
  <link id="hljs-light" rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" disabled>
  <link id="hljs-dark" rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" disabled>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
    (function () {
      const light = document.getElementById('hljs-light');
      const dark = document.getElementById('hljs-dark');
      if (!light || !dark) return;

      function resolveTheme() {
        return document.documentElement.getAttribute('data-theme') || 'light';
      }

      function applyTheme(theme) {
        const isDark = theme === 'dark';
        light.disabled = isDark;
        dark.disabled = !isDark;
      }

      const observer = new MutationObserver(function () {
        applyTheme(resolveTheme());
      });
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
      applyTheme(resolveTheme());
    })();
  </script>
  <!-- highlight.js end -->

<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">




    <meta name="tags" content="C" />
    <meta name="tags" content="array" />
    <meta name="tags" content="malloc" />
    <meta name="tags" content="memory leak" />

</head>

<body>
  <header>
    <div id="header-container">
      <button id="nav-toggle" class="nav-toggle" aria-label="打开菜单" aria-expanded="false">
        <i class="fa-solid fa-bars" aria-hidden="true"></i>
      </button>
      <nav id="site-nav">
        <ul>
            <li>
              <a href="/">Home</a>
            </li>
            <li>
              <a href="/category/physics">Physics</a>
            </li>
            <li>
              <a href="/category/blog">Blog</a>
            </li>
            <li>
              <a href="/category/coding">Coding</a>
            </li>
            <li>
              <a href="/archives">All</a>
            </li>
          </ul>
      </nav>
      <div class="header-actions">
        <button id="theme-toggle" aria-label="切换到深色模式" title="切换主题">
          <i class="theme-icon icon-sun fa-solid fa-sun" aria-hidden="true"></i>
          <i class="theme-icon icon-moon fa-solid fa-moon" aria-hidden="true"></i>
        </button>
        <div class="rss">
            <a href="https://zqw.ink/feeds/all.atom.xml" aria-label="Atom 订阅">
              <i class="fa-solid fa-rss" aria-hidden="true"></i>
            </a>
        </div>
      </div>
    </div>
  </header>
  <main>

<h1 class="post-title">C 中的指针与动态内存分配</h1>

<section class="post-meta">
    <p>2021-05-14</p>
    <p>-<a class="post-link" href="https://zqw.ink/category/ruan-jian-shi-yong.html">软件使用</a></p>
</section>

<section class="markdown-body">
  
<p>主要是为 Reference 存个书签.</p>

<h2>Pointers</h2>

<p>在写程序的过程中, array 是相当有用的. 但是 array 是静态的, 也就是它的大小不能改
变. 此时指针就派上用场.</p>

<p>在 C 中, pointer 表示一个 data 的内存地址. 如果一个 pointer 为 0, 那它叫做 null
pointer, 也叫 NULL , "nil" .</p>

<h2>Declarations</h2>

<p>指针声明的方式是, 在一个已经存在的数据类型前加一个 <code>*</code>. 如</p>

<pre><code class="language-c">int *ip;</code></pre>

<p>声明了一个名为 <code>ip</code> 的 pointer 指向一个整数.</p>

<p>创建一个指针的方法是用算符 <code>&</code> (address-of) . 顾名思义, 它作用到一个变量后, 得到它
的地址. 如</p>

<pre><code class="language-c">int *ip;
int x;
x = 42;
ip = &x;</code></pre>

<p>将 <code>42</code> 赋值给 <code>x</code>, 将 <code>x</code> 的地址赋值给 <code>ip</code>.</p>

<h2>Using a pointer</h2>

<p>使用 pointer 的方法是使用算符 <code>*</code> , 它叫做 dereference operator. 它作用在一个指针
上, 得到的结果是它指向的内存地址中的值.</p>

<pre><code class="language-c">printf("%d %d\n", x, *ip);</code></pre>

<p>会输出 <code>42 42</code> .</p>

<p>也可以</p>

<pre><code class="language-c">*ip = 37;</code></pre>
<p>此时, 这块内存中的值就变成了 <code>37</code> .</p>

<h2>Memory allocation and deallocation</h2>


<p>一般来讲, 把一个指针指向一个已经声明的变量, 没什么用. 真正有用的是用它来分配一块
没有使用的内存. 这使得程序能够处理大量的内存.</p>

<p>基本的内存分配函数是</p>

<pre><code class="language-c">(void *) malloc(size_t numbytes);</code></pre>

<p>它的意思是分出一定数量的内存空间, 并返回一个指向它的指针. 由于  malloc 不知道你
想要什么类型的指针, 它返回的是 pointer to void, 也就是指向一块数据类型不明的区域.</p>

<p>常用的是把它和内置算符 <code>sizeof()</code> 放在一起用. <code>sizeof()</code> 返回特定数据类型的比特
数. 如</p>

<pre><code class="language-c">int *ip;
ip = (int *) malloc(sizeof(int));</code></pre>

<p>这将分配出 1 个 <code>int</code> 大小的内存, 将其指针给 <code>ip</code> .</p>

<h2>Pointers and arrays</h2>

<p>分配单个整型大小的内存没什么用, 有用的是 allocate arrays. 实际上, 指针可以当作一
个 array 用. 如</p>
<pre><code class="language-c">int *ip;
ip = (int *) malloc( sizeof(int)*10 ); // allocate 10 ints
ip[6] = 42; // set the 7th element to 42
ip[10] = 99; // WRONG: array only has 10 elements
(this would corrupted memory!)</code></pre>

<h2>Freeing memory, and memory leaks</h2>

<p>如果有以下 code</p>

<pre><code class="language-c">int *ip;
ip = (int *) malloc( sizeof(int)*10 ); // allocate 10 ints
... (use the array, etc.)
ip = (int *) malloc( sizeof(int)*100 ); // allocate 100 ints
...</code></pre>

<p>它没有金鼓齐鸣. 可以给一个指针重新赋值. 但是重新赋值之后, 之前分出的那 10 ints
的内存呢? 答案是它永远地消失了, 直到程序结束. 这叫内存(memory leak). 虽然这 10
ints 内存是被分配的, 但程序再也无法使用这些内存了.</p>

<p>解决方法是, 在 C 或者 C++ 中, 当被分配的内存用完后, 可以通过 <code>free()</code> 来释放内存.
如</p>

<pre><code class="language-c    int *ip;">ip = (int *) malloc( sizeof(int)*10 ); // allocate 10 ints
... (use the array, etc.)
free(ip); // de-allocate old array
ip = (int *) malloc( sizeof(int)*100 ); // allocate 100 ints
...</code></pre>

<p>上面的 code 就不会发生内存泄漏. 有一些语言 (如 Java) 会自动清理分配的内存, 这叫
automatic garbage collection , 但是 C 和 C++ 没有这种机制. 所以你在用完后, 应该
负责释放掉它们.</p>

<h2>Pointers and arrays</h2>

<p>pointers 可以用 array 的指标, 或者说, 一个数组的名字本质上就是一个 constant
pointer.</p>

<pre><code class="language-c">int *p;
int a[10];
p = (int*) malloc(sizeof(int)*20);
p[2] = 100; // set 3rd element in alloc'd array to 100
*(p+2) = 100; // same thing
a[2] = 200; // set 3rd element in regulary array to 200
*(a+2) = 200; // same thing</code></pre>

<p>指针和数组是不同的, 但是当指针被用来 access 一块区域时, 用法是一样的. 但是</p>

<blockquote>- the array declares a block of some datatype while a pointer only declares
  space for itself (the data area needs malloc'd)

  数组会声明一块特定数据类型的区域, 而指针只会声明这块空间本身.

- The address of the array (i.e., a pointer to it) is not stored anywhere; the
    compiler figures it out while it is compiling your program, so when you use
    the array name as a pointer, you are essentially using a constant number as
    an address.

  数组的地址没有存在任何地方, 编译器编译的时候才搞清它. 所以将数组的名字当作指针
  使用的时候, 本质上是将一个常数当作地址使用.</blockquote>

<h2>Pointers and arrays as arguments</h2>

<p>有一个地方,指针和数组几乎是完全相同的, 那就是 当它们作为一个函数的参数的时候. 这
是因为 agruments pass only the address of the array to the function. 也就是说数
组作为指针传递.</p>

<p>在 C 中, 大部分值的传递方法是 call-by-value, 函数得到的是值的一个副本, 函数不会
改变原来的值. 但数组的传递方法是 call-by-reference, 传递的是指针, 而不是数组本
身.</p>

<p>如果传递数组时, 传递一个副本的话, 当数组非常大时, 那是非常浪费的. 所以数值的传递
方法是 call-by-reference. 这也意味着函数中对数组的修改, 会直接修改原来的数组.</p>

<p>因此, 下面的声明是等价的</p>
<pre><code class="language-c">int func(int A[]);
int func(int *A);</code></pre>

<h2>How to dynamically allocate a 2D array in C?</h2>

<p>有四种方法能够动态的给一个二维数组赋值. 比如</p>
<pre><code class="language-c">  1  2  3  4
  5  6  7  8
  9  10 11 12</code></pre>

<h3>1. Using a single pointer</h3>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int r = 3, c = 4;
    int *arr = (int *)malloc(r * c * sizeof(int));

    int i, j, count = 0;
    for (i = 0; i &lt;  r; i++)
      for (j = 0; j &lt; c; j++)
         *(arr + i*c + j) = ++count;

    for (i = 0; i &lt;  r; i++)
      for (j = 0; j &lt; c; j++)
         printf("%d ", *(arr + i*c + j));

   /* Code for further processing and free the
      dynamically allocated memory */

   return 0;
}</code></pre>

<h3>2. Using an array of pointers</h3>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
	int r = 3, c = 4, i, j, count;

	int *arr[r];
	for (i=0; i&lt;r; i++)
		arr[i] = (int *)malloc(c * sizeof(int));

	// Note that arr[i][j] is same as *(*(arr+i)+j)
	count = 0;
	for (i = 0; i &lt; r; i++)
	for (j = 0; j &lt; c; j++)
		arr[i][j] = ++count; // Or *(*(arr+i)+j) = ++count

	for (i = 0; i &lt; r; i++)
	for (j = 0; j &lt; c; j++)
		printf("%d ", arr[i][j]);

	/* Code for further processing and free the
	dynamically allocated memory */

return 0;
}</code></pre>

<h3>3. Using pointer to a pointer</h3>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
	int r = 3, c = 4, i, j, count;

	int **arr = (int **)malloc(r * sizeof(int *));
	for (i=0; i&lt;r; i++)
		arr[i] = (int *)malloc(c * sizeof(int));

	// Note that arr[i][j] is same as *(*(arr+i)+j)
	count = 0;
	for (i = 0; i &lt; r; i++)
	for (j = 0; j &lt; c; j++)
		arr[i][j] = ++count; // OR *(*(arr+i)+j) = ++count

	for (i = 0; i &lt; r; i++)
	for (j = 0; j &lt; c; j++)
		printf("%d ", arr[i][j]);

/* Code for further processing and free the
	dynamically allocated memory */

return 0;
}</code></pre>

<h3>4. Using double pointer and one malloc call</h3>

<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
	int r=3, c=4, len=0;
	int *ptr, **arr;
	int count = 0,i,j;

	len = sizeof(int *) * r + sizeof(int) * c * r;
	arr = (int **)malloc(len);

	// ptr is now pointing to the first element in of 2D array
	ptr = (int *)(arr + r);

	// for loop to point rows pointer to appropriate location in 2D array
	for(i = 0; i &lt; r; i++)
		arr[i] = (ptr + c * i);

	for (i = 0; i &lt; r; i++)
		for (j = 0; j &lt; c; j++)
			arr[i][j] = ++count; // OR *(*(arr+i)+j) = ++count

	for (i = 0; i &lt; r; i++)
		for (j = 0; j &lt; c; j++)
			printf("%d ", arr[i][j]);

	return 0;
}</code></pre>

<h2>Memory leak</h2>

<p>下面的 code 可以演示内存泄漏</p>
<pre><code class="language-c">include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;

 void f(void)
 {
     void* s;
     s = malloc(50); /* 申请内存空间 */
     return;  /* 内在泄漏 - 参见以下资料 */
     /*
      * s 指向新分配的堆空间。
      * 当此函数返回，离开局部变量s的作用域后将无法得知s的值，
      * 分配的内存空间不能被释放。
      *
      * 如要「修复」这个问题，必须想办法释放分配的堆空间，
      * 也可以用alloca(3)代替malloc(3)。
      * （注意：alloca(3)既不是ANSI函数也不是POSIX函数）
      */
 }
 int main(void)
 {
     /* 该函数是一个死循环函数 */
     while (1) f(); /* Malloc函数迟早会由于内存泄漏而返回NULL*/
     return 0;
 }</code></pre>

<p>结果是几秒后内存就满了. 但是系统会有保护机制? 直接杀掉了进程([[file:2021-05-14-coding-C_pointer_malloc/memory_leak.c][memory_leak.c]] [[file:2021-05-14-coding-C_pointer_malloc/makefile][makefile]]):</p>

<p><p><img src='2021-05-14-coding-C_pointer_malloc/memory_leak_res.png' alt='figalt' max-width:100%><p></p>

<h2>Reference</h2>

<ul>
<li>https://www.cs.nmsu.edu/~rth/cs/cs271/notes/Pointers.html</li>
<li>https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/</li>
<li><a href='https://zh.wikipedia.org/zh-cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F'>wikipedia: 内存泄漏</a></li>
<li><a href='https://en.wikipedia.org/wiki/Dereference_operator'>wikipeida: Dereference operator</a></li>
</ul>

</section>

<section class="post-meta">
    <p>
        <a class="post-link" href="https://zqw.ink/tag/c.html">#C</a>
        <a class="post-link" href="https://zqw.ink/tag/array.html">#array</a>
        <a class="post-link" href="https://zqw.ink/tag/malloc.html">#malloc</a>
        <a class="post-link" href="https://zqw.ink/tag/memory-leak.html">#memory leak</a>
    </p>
</section>

  </main>
  <footer role="contentinfo">
    <p>Copyright &copy; 2018 - 2025 ZQW</p>
  </footer>
  <script>
  (function() {
    const key = 'theme';
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const saved = localStorage.getItem(key);
    const init = saved ? saved : 'system';
    const effective = init === 'system' ? (prefersDark ? 'dark' : 'light') : init;
    document.documentElement.setAttribute('data-theme', effective);
    updateThemeButton(effective);

    document.getElementById('theme-toggle')?.addEventListener('click', function () {
      const current = document.documentElement.getAttribute('data-theme') || 'light';
      const next = current === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      localStorage.setItem(key, next);
      updateThemeButton(next);
    });

    function updateThemeButton(theme) {
      const btn = document.getElementById('theme-toggle');
      if (btn) {
        btn.setAttribute('aria-label', theme === 'dark' ? '切换到浅色模式' : '切换到深色模式');
      }
    }
  })();
  </script>
  <script>
  (function() {
    const blocks = document.querySelectorAll('pre > code');
    blocks.forEach((code) => {
      const pre = code.parentElement;
      if (!pre) return;

      if (!pre.dataset.lang) {
        const cls = Array.from(code.classList);
        const langClass = cls.find((name) => name.startsWith('language-') || name.startsWith('lang-'));
        if (langClass) {
          const raw = langClass.replace(/^language-/, '').replace(/^lang-/, '');
          pre.dataset.lang = raw.replace(/_/g, ' ').toUpperCase();
        }
      }

      if (pre.querySelector('.copy-btn')) return;
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'copy-btn';
      btn.setAttribute('aria-label', '复制代码');
      btn.textContent = 'Copy';
      btn.addEventListener('click', async function () {
        try {
          await navigator.clipboard.writeText(code.innerText);
          btn.textContent = 'Copied';
        } catch (err) {
          const range = document.createRange();
          range.selectNodeContents(code);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          try {
            document.execCommand('copy');
            btn.textContent = 'Copied';
          } finally {
            selection.removeAllRanges();
          }
        }
        setTimeout(() => {
          btn.textContent = 'Copy';
        }, 1500);
      });
      pre.appendChild(btn);
    });
  })();
  </script>
  <script>
  (function() {
    const toggle = document.getElementById('nav-toggle');
    const nav = document.getElementById('site-nav');
    if (!toggle || !nav) return;

    function closeNav() {
      nav.classList.remove('is-open');
      toggle.setAttribute('aria-expanded', 'false');
      toggle.setAttribute('aria-label', '打开菜单');
    }

    function openNav() {
      nav.classList.add('is-open');
      toggle.setAttribute('aria-expanded', 'true');
      toggle.setAttribute('aria-label', '关闭菜单');
    }

    toggle.addEventListener('click', function (event) {
      event.stopPropagation();
      const isOpen = nav.classList.contains('is-open');
      if (isOpen) {
        closeNav();
      } else {
        openNav();
      }
    });

    nav.querySelectorAll('a').forEach((link) => {
      link.addEventListener('click', closeNav);
    });

    document.addEventListener('click', function (event) {
      if (!nav.classList.contains('is-open')) return;
      if (nav.contains(event.target) || toggle.contains(event.target)) return;
      closeNav();
    });
  })();
  </script>
</body>

</html>